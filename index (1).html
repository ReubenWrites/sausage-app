<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What Sausage Are You?</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Upload a photo and discover your true sausage identity!">
    <meta name="theme-color" content="#E4A801">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sausage App">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Icons for iOS -->
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Patrick+Hand&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --mustard: #E4A801;
            --ketchup: #C41E3A;
            --bun: #D4956A;
            --meat: #8B4513;
            --charred: #2D1810;
            --cream: #FFF8E7;
        }

        body {
            font-family: 'Patrick Hand', cursive;
            background: var(--cream);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(228, 168, 1, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(196, 30, 58, 0.1) 0%, transparent 50%),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(139, 69, 19, 0.03) 10px,
                    rgba(139, 69, 19, 0.03) 20px
                );
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }

        .header {
            padding: 30px 0;
        }

        .header h1 {
            font-family: 'Fredoka One', cursive;
            font-size: 2.8rem;
            color: var(--charred);
            text-shadow: 3px 3px 0 var(--mustard);
            margin-bottom: 10px;
            animation: sizzle 0.5s ease-in-out infinite alternate;
        }

        @keyframes sizzle {
            from { transform: rotate(-1deg); }
            to { transform: rotate(1deg); }
        }

        .header p {
            font-size: 1.3rem;
            color: var(--meat);
        }

        .sausage-deco {
            font-size: 3rem;
            margin: 10px 0;
            animation: bounce 1s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .loading-models {
            background: linear-gradient(145deg, #fff, #f5f0e0);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .loading-models h3 {
            font-family: 'Fredoka One', cursive;
            color: var(--charred);
            margin-bottom: 15px;
        }

        .loading-spinner {
            font-size: 2rem;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .upload-area {
            background: linear-gradient(145deg, #fff, #f5f0e0);
            border: 4px dashed var(--mustard);
            border-radius: 30px;
            padding: 40px 20px;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: var(--ketchup);
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(139, 69, 19, 0.2);
        }

        .upload-area.dragover {
            background: linear-gradient(145deg, var(--mustard), #f5c842);
            border-color: var(--ketchup);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.4rem;
            color: var(--charred);
        }

        .upload-subtext {
            font-size: 1rem;
            color: var(--meat);
            margin-top: 10px;
        }

        #file-input {
            display: none;
        }

        .preview-container {
            display: none;
            margin: 20px 0;
        }

        .preview-container.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .preview-image {
            max-width: 300px;
            max-height: 300px;
            object-fit: contain;
            border-radius: 20px;
            border: 5px solid var(--mustard);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .faces-found {
            margin-top: 15px;
            font-size: 1.2rem;
            color: var(--ketchup);
            font-family: 'Fredoka One', cursive;
        }

        .analyze-btn {
            display: none;
            background: linear-gradient(145deg, var(--ketchup), #a01830);
            color: white;
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            padding: 15px 50px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 20px 0;
            box-shadow: 0 5px 0 #7a1225, 0 10px 20px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .analyze-btn.show {
            display: inline-block;
            animation: fadeIn 0.5s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 0 #7a1225, 0 15px 25px rgba(0,0,0,0.3);
        }

        .analyze-btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 0 #7a1225, 0 5px 10px rgba(0,0,0,0.2);
        }

        .analysis-screen {
            display: none;
            padding: 40px 20px;
        }

        .analysis-screen.show {
            display: block;
        }

        .analysis-text {
            font-size: 1.5rem;
            color: var(--charred);
            margin: 20px 0;
            min-height: 60px;
        }

        .spinner {
            width: 100px;
            height: 100px;
            margin: 20px auto;
            position: relative;
            animation: spin 2s linear infinite;
        }

        .spinner::before {
            content: 'üå≠';
            font-size: 4rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mustard), var(--ketchup));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .results-screen {
            display: none;
            padding: 20px;
        }

        .results-screen.show {
            display: block;
            animation: fadeIn 0.8s ease;
        }

        .result-title {
            font-family: 'Fredoka One', cursive;
            font-size: 1.8rem;
            color: var(--charred);
            margin-bottom: 20px;
        }

        .sausages-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .sausage-card {
            background: linear-gradient(145deg, #fff, #f5f0e0);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            width: 280px;
            animation: popIn 0.5s ease backwards;
            transition: transform 0.2s ease;
        }
        
        .sausage-card:hover {
            transform: scale(1.03) rotate(1deg);
        }
        
        .sausage-card:hover .sausage-svg {
            animation: wobble 0.5s ease;
        }
        
        @keyframes wobble {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-3deg); }
            75% { transform: rotate(3deg); }
        }

        .sausage-card:nth-child(1) { animation-delay: 0.1s; }
        .sausage-card:nth-child(2) { animation-delay: 0.2s; }
        .sausage-card:nth-child(3) { animation-delay: 0.3s; }
        .sausage-card:nth-child(4) { animation-delay: 0.4s; }
        .sausage-card:nth-child(5) { animation-delay: 0.5s; }

        @keyframes popIn {
            from { 
                opacity: 0; 
                transform: scale(0.5) rotate(-10deg); 
            }
            to { 
                opacity: 1; 
                transform: scale(1) rotate(0deg); 
            }
        }

        .sausage-result {
            position: relative;
            width: 240px;
            height: 280px;
            margin: 0 auto;
        }

        .sausage-body {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sausage-svg {
            width: 100%;
            height: 100%;
        }

        .face-overlay {
            position: absolute;
            width: 115px;
            height: 150px;
            object-fit: contain;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.3)) sepia(85%) saturate(160%) hue-rotate(-20deg) brightness(1.15) contrast(1.1);
            mix-blend-mode: normal;
        }

        .sausage-type {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            color: var(--ketchup);
            margin: 10px 0 5px;
            text-shadow: 1px 1px 0 var(--mustard);
        }

        .sausage-description {
            font-size: 1.05rem;
            color: var(--charred);
            line-height: 1.4;
            padding: 0 5px;
        }
        
        .sausage-names {
            font-size: 0.95rem;
            color: var(--meat);
            margin: 10px 0;
            padding: 8px 12px;
            background: rgba(139, 69, 19, 0.08);
            border-radius: 8px;
        }
        
        .sausage-names-label {
            font-family: 'Fredoka One', cursive;
            font-size: 0.85rem;
            color: var(--mustard);
            display: block;
            margin-bottom: 4px;
        }
        
        .sausage-names-list {
            font-style: italic;
        }
        
        .sausage-quote {
            font-size: 1.1rem;
            font-style: italic;
            color: var(--ketchup);
            background: linear-gradient(135deg, rgba(228, 168, 1, 0.15), rgba(196, 30, 58, 0.1));
            border-left: 4px solid var(--mustard);
            padding: 10px 15px;
            margin: 0 0 -5px 0;
            border-radius: 0 10px 10px 0;
        }
        
        .sausage-quote::before {
            content: '"';
        }
        
        .sausage-quote::after {
            content: '"';
        }

        .stats {
            background: rgba(139, 69, 19, 0.1);
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 0.95rem;
        }

        .stat-label {
            flex: 0 0 100px;
            text-align: left;
            color: var(--meat);
        }

        .stat-bar {
            flex: 1;
            height: 12px;
            background: #ddd;
            border-radius: 6px;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 1s ease;
        }

        .stat-fill.sizzle { background: linear-gradient(90deg, #ff6b35, #f7c59f); }
        .stat-fill.meat { background: linear-gradient(90deg, #8B4513, #D2691E); }
        .stat-fill.banger { background: linear-gradient(90deg, var(--ketchup), #ff6b6b); }

        .try-again-btn {
            background: linear-gradient(145deg, var(--mustard), #c99000);
            color: var(--charred);
            font-family: 'Fredoka One', cursive;
            font-size: 1.3rem;
            padding: 12px 40px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin: 20px 10px;
            box-shadow: 0 4px 0 #a07800, 0 8px 15px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .try-again-btn:hover {
            transform: translateY(-2px);
        }

        .footer {
            margin-top: 40px;
            padding: 20px;
            font-size: 1rem;
            color: var(--meat);
        }

        #face-canvas, #source-image, #temp-canvas {
            display: none;
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .sausage-card {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≠ What Sausage Are You? üå≠</h1>
            <p>Upload a photo and discover your true sausage identity</p>
            <div class="sausage-deco">üç≥</div>
        </div>

        <div class="loading-models" id="loading-models">
            <h3><span class="loading-spinner">üå≠</span> Heating up the frying pan...</h3>
            <p>Loading advanced face detection...</p>
        </div>

        <div id="upload-screen" style="display: none;">
            <div class="upload-area" id="upload-area">
                <div class="upload-icon">üì∏</div>
                <div class="upload-text">Tap to upload a photo</div>
                <div class="upload-subtext">Works with selfies, group photos, family pics...</div>
            </div>
            <input type="file" id="file-input" accept="image/*">

            <div class="preview-container" id="preview-container">
                <img id="preview-image" class="preview-image" src="" alt="Preview">
                <div class="faces-found" id="faces-found"></div>
            </div>

            <button class="analyze-btn" id="analyze-btn">üî• SAUSAGE-IFY! üî•</button>
        </div>

        <div class="analysis-screen" id="analysis-screen">
            <div class="spinner"></div>
            <div class="analysis-text" id="analysis-text">Initializing sausage scanner...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>

        <div class="results-screen" id="results-screen">
            <div class="result-title">üéâ Sausage Analysis Complete! üéâ</div>
            
            <div class="sausages-grid" id="sausages-grid"></div>

            <button class="try-again-btn" id="try-again-btn">üîÑ Try Another Photo</button>
        </div>

        <div class="footer">
            Made with üå≠ and questionable life choices
        </div>
    </div>

    <canvas id="face-canvas"></canvas>
    <canvas id="temp-canvas"></canvas>
    <img id="source-image">

    <script>
        // Sausage types database
        const sausageTypes = [
            {
                name: "Classic Banger",
                description: "A proper British staple. Reliable, no-nonsense, and the backbone of every full English.",
                color: "#C4956A",
                highlight: "#D4A574",
                quotes: [
                    "I don't need to be fancy. I need to be ON THE PLATE.",
                    "Beans fear me. Eggs respect me. Toast knows its place.",
                    "I've held this fry-up together since 1952 and I'm not stopping now.",
                    "You want innovation? I AM the innovation. Everything else is just noise.",
                    "Some call it simple. I call it PERFECTION."
                ],
                names: ["Keith", "Brenda", "Colin", "Janet", "Derek", "Maureen", "Trevor", "Linda", "Graham", "Pauline", "Brian", "Sheila"]
            },
            {
                name: "Chipolata",
                description: "Small but mighty! Often underestimated, always delivers. Life of the buffet table.",
                color: "#B8860B",
                highlight: "#DAA520",
                quotes: [
                    "I come in NUMBERS. You cannot stop us all.",
                    "Underestimate me. I dare you. I DOUBLE dare you.",
                    "Fun-sized? I prefer CONCENTRATED EXCELLENCE.",
                    "One of me is a snack. Six of me is a LIFESTYLE.",
                    "I'm not small, I'm TRAVEL-SIZED FOR YOUR CONVENIENCE."
                ],
                names: ["Pip", "Midge", "Titch", "Buttons", "Pixie", "Nugget", "Dinky", "Sprout", "Bean", "Peanut", "Zippy", "Bitsy"]
            },
            {
                name: "Cumberland Coil",
                description: "One continuous spiral of drama and chaos. High maintenance but worth it.",
                color: "#8B4513",
                highlight: "#A0522D",
                quotes: [
                    "I don't do PORTIONS. I am the WHOLE PERFORMANCE.",
                    "Straight sausages are for people who fear COMMITMENT.",
                    "I'm not dramatic, I'm GEOMETRICALLY SUPERIOR.",
                    "Uncoil me if you dare. But know this: I WILL remember.",
                    "Some see a spiral. I see DESTINY."
                ],
                names: ["Cornelius", "Arabella", "Montgomery", "Theodora", "Sebastian", "Lavinia", "Reginald", "Cordelia", "Bartholomew", "Evangeline", "Rupert", "Octavia"]
            },
            {
                name: "Bratwurst",
                description: "Takes themselves seriously. Probably owns a barbecue. Strong opinions about mustard.",
                color: "#D2691E",
                highlight: "#E07020",
                quotes: [
                    "Ketchup? We don't DO that here.",
                    "I didn't choose the wurst life. The wurst life chose ME.",
                    "My mustard pairing is not a SUGGESTION, it's a REQUIREMENT.",
                    "I've been grilled by professionals. You don't scare me.",
                    "This isn't a barbecue. This is a CEREMONY."
                ],
                names: ["Hans", "Greta", "Wolfgang", "Helga", "Klaus", "Ingrid", "Fritz", "Brunhilde", "Dieter", "Ursula", "G√ºnther", "Heidi"]
            },
            {
                name: "Cocktail Sausage",
                description: "Fun-sized party animal! Wrapped in bacon at every opportunity. Living their best life.",
                color: "#CD853F",
                highlight: "#DEB887",
                quotes: [
                    "I'm not here for nutrition. I'm here for VIBES.",
                    "Wrap me in bacon and watch me TRANSCEND.",
                    "Every party I attend becomes ABOUT me. That's just science.",
                    "I peaked in the 70s and I've simply refused to come down.",
                    "Toothpick? That's my THRONE."
                ],
                names: ["Ricky", "Cheryl", "Darren", "Tracey", "Gaz", "Shaz", "Baz", "Tanya", "Kev", "Donna", "Macca", "Babs"]
            },
            {
                name: "Veggie Sausage",
                description: "Trying their best! Not quite the real thing, but honestly? Sometimes even better.",
                color: "#6B8E23",
                highlight: "#9ACD32",
                quotes: [
                    "I'm not pretending to be meat. Meat wishes it was ME.",
                    "Plants have POWER. I am that power, in tube form.",
                    "Saving the planet one BBQ at a time. You're WELCOME.",
                    "I don't need to justify myself. I need BROWN SAUCE.",
                    "The future is GREEN. The future is ME."
                ],
                names: ["Sage", "Willow", "Quinoa", "River", "Meadow", "Basil", "Fern", "Kale", "Saffron", "Moss", "Luna", "Indigo"]
            },
            {
                name: "Saveloy",
                description: "LOUD. Unapologetic. Bright red and proud. A chippy legend, probably from Essex.",
                color: "#DC143C",
                highlight: "#FF6B6B",
                quotes: [
                    "YES I'M THIS RED. WHAT OF IT?",
                    "I don't go with chips. Chips go with ME.",
                    "Subtle? Don't know her. Never met her. Don't want to.",
                    "I'm not blushing, this is my POWER COLOUR.",
                    "The chippy is my KINGDOM and I rule it ABSOLUTELY."
                ],
                names: ["Big Kev", "Tiffany", "Dwayne", "Chardonnay", "Tyson", "Destiny", "Jayden", "Mercedes", "Keanu", "Porsche", "Blade", "Chanel"]
            },
            {
                name: "Black Pudding",
                description: "Technically not a sausage, but who's checking? A wildcard. Some love you, some fear you.",
                color: "#1C1C1C",
                highlight: "#3D3D3D",
                quotes: [
                    "I'm not a sausage and I don't CARE what you think.",
                    "You either get me or you DON'T. There is no middle ground.",
                    "Yes, you know what I'm made of. We're PAST that now.",
                    "I am inevitable. I am BREAKFAST.",
                    "Fear is the correct response. Respect is EARNED."
                ],
                names: ["Morticia", "Damien", "Raven", "Vlad", "Elvira", "Draven", "Lilith", "Salem", "Noir", "Shadow", "Onyx", "Grimm"]
            },
            {
                name: "Frankfurter",
                description: "Long, sophisticated, probably wearing a turtleneck. The jazz of sausages.",
                color: "#F4A460",
                highlight: "#FFDAB9",
                quotes: [
                    "I don't need a bun. The bun needs ME.",
                    "Some see a hot dog. I see an EXPERIENCE.",
                    "I've been in jars. I've seen things. I've GROWN.",
                    "Elegance isn't taught. It's ENCASED.",
                    "New York couldn't handle me. That's why I went solo."
                ],
                names: ["Miles", "Celeste", "Julian", "Margot", "Benedict", "Simone", "Caspian", "Delphine", "Quentin", "Am√©lie", "Sterling", "Giselle"]
            },
            {
                name: "Square Sausage",
                description: "Scottish icon! Doesn't conform to cylindrical norms. Essential to any morning roll.",
                color: "#696969",
                highlight: "#808080",
                quotes: [
                    "Round? In THIS economy? Absolutely NOT.",
                    "I fit the roll PERFECTLY. Coincidence? I think not.",
                    "Scotland knew what it was doing. You're WELCOME, world.",
                    "Corners are not a flaw. They're a FEATURE.",
                    "I rejected the cylinder. The cylinder did NOT reject me."
                ],
                names: ["Angus", "Morag", "Hamish", "Isla", "Fergus", "Ailsa", "Ewan", "Mhairi", "Callum", "Shona", "Lachlan", "Bonnie"]
            }
        ];

        const analysisMessages = [
            "Scanning for sausage potential...",
            "Mapping 468 meaty landmarks...",
            "Calculating casing compatibility...",
            "Assessing sizzle factor...",
            "Extracting your inner banger...",
            "Applying sausage-ification...",
            "Analyzing banger energy...",
            "Detecting seasoning preferences...",
            "Evaluating fry-ability...",
            "Consulting the sausage oracle...",
            "Determining your destiny..."
        ];

        // MediaPipe face mesh landmark indices for face outline
        // These create a complete face silhouette
        const FACE_OVAL_INDICES = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];
        
        // Forehead points (top of face) 
        const FOREHEAD_INDICES = [10, 109, 67, 103, 54, 21, 162, 127, 234, 93, 132, 58, 172, 136, 150, 149, 176, 148, 152];
        
        // Complete face boundary including forehead estimation
        const FACE_BOUNDARY = [
            // Forehead (we'll extrapolate up from eyebrows)
            // Right side of face going down
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            // Chin
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            // Left side going up
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // DOM elements
        const loadingModels = document.getElementById('loading-models');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const previewContainer = document.getElementById('preview-container');
        const previewImage = document.getElementById('preview-image');
        const sourceImage = document.getElementById('source-image');
        const facesFound = document.getElementById('faces-found');
        const analyzeBtn = document.getElementById('analyze-btn');
        const uploadScreen = document.getElementById('upload-screen');
        const analysisScreen = document.getElementById('analysis-screen');
        const resultsScreen = document.getElementById('results-screen');
        const analysisText = document.getElementById('analysis-text');
        const progressFill = document.getElementById('progress-fill');
        const sausagesGrid = document.getElementById('sausages-grid');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const faceCanvas = document.getElementById('face-canvas');
        const tempCanvas = document.getElementById('temp-canvas');
        const ctx = faceCanvas.getContext('2d');
        const tempCtx = tempCanvas.getContext('2d');

        let faceMesh = null;
        let detectedFaceLandmarks = [];
        let imageDataUrl = null;
        let modelsLoaded = false;

        // Initialize MediaPipe Face Mesh
        async function initFaceMesh() {
            try {
                faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });
                
                faceMesh.setOptions({
                    maxNumFaces: 10,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                faceMesh.onResults(onFaceMeshResults);
                
                // Warm up the model
                await faceMesh.initialize();
                
                console.log('MediaPipe Face Mesh loaded!');
                modelsLoaded = true;
                loadingModels.style.display = 'none';
                uploadScreen.style.display = 'block';
            } catch (error) {
                console.error('Error loading Face Mesh:', error);
                loadingModels.innerHTML = `
                    <h3>‚ö†Ô∏è Couldn't load face detection</h3>
                    <p>Don't worry - you can still use the app!</p>
                    <button onclick="skipModels()" style="margin-top: 15px; padding: 10px 30px; font-size: 1.1rem; cursor: pointer; border-radius: 25px; border: none; background: var(--mustard); color: var(--charred); font-family: 'Fredoka One', cursive;">Continue Anyway üå≠</button>
                `;
            }
        }

        function skipModels() {
            loadingModels.style.display = 'none';
            uploadScreen.style.display = 'block';
        }

        let faceMeshResolve = null;
        
        function onFaceMeshResults(results) {
            console.log('Face mesh results:', results.multiFaceLandmarks?.length || 0, 'faces');
            detectedFaceLandmarks = results.multiFaceLandmarks || [];
            if (faceMeshResolve) {
                faceMeshResolve();
                faceMeshResolve = null;
            }
        }

        initFaceMesh();

        // Upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file!');
                return;
            }

            const reader = new FileReader();
            
            reader.onload = async (e) => {
                imageDataUrl = e.target.result;
                previewImage.src = imageDataUrl;
                previewContainer.classList.add('show');
                facesFound.textContent = 'üîç Scanning for faces...';
                facesFound.style.display = 'block';
                analyzeBtn.classList.remove('show');
                
                previewImage.onload = async () => {
                    sourceImage.src = imageDataUrl;
                    sourceImage.onload = async () => {
                        await detectFaces();
                        analyzeBtn.classList.add('show');
                    };
                };
            };
            
            reader.readAsDataURL(file);
        }

        async function detectFaces() {
            detectedFaceLandmarks = [];
            
            if (!modelsLoaded || !faceMesh) {
                facesFound.textContent = 'üì∏ Photo ready!';
                return;
            }
            
            try {
                console.log('Running face mesh detection...');
                
                // Create a promise that resolves when we get results
                const resultPromise = new Promise(resolve => {
                    faceMeshResolve = resolve;
                });
                
                // Send image to face mesh
                await faceMesh.send({ image: sourceImage });
                
                // Wait for results
                await resultPromise;
                
                if (detectedFaceLandmarks.length > 0) {
                    const faceText = detectedFaceLandmarks.length === 1 
                        ? 'üéØ 1 face detected (468 points mapped!)' 
                        : `üéØ ${detectedFaceLandmarks.length} faces detected!`;
                    facesFound.textContent = faceText;
                } else {
                    facesFound.textContent = 'ü§î No faces found - we\'ll use the whole photo!';
                }
            } catch (e) {
                console.error('Face detection error:', e);
                facesFound.textContent = 'üì∏ Photo ready!';
            }
        }

        function extractFaceWithPreciseMask(landmarks) {
            const img = sourceImage;
            const imgWidth = img.naturalWidth;
            const imgHeight = img.naturalHeight;
            
            // Convert normalized landmarks to pixel coordinates
            const points = landmarks.map(pt => ({
                x: pt.x * imgWidth,
                y: pt.y * imgHeight
            }));
            
            // Get key facial points
            const foreheadTop = points[10];
            const leftEyebrow = points[70];
            const rightEyebrow = points[300];
            const noseTip = points[4];
            const chin = points[152];
            const leftCheek = points[234];
            const rightCheek = points[454];
            const leftJaw = points[136];
            const rightJaw = points[365];
            const leftTemple = points[21];
            const rightTemple = points[251];
            
            // Calculate face dimensions
            const eyebrowY = Math.min(leftEyebrow.y, rightEyebrow.y);
            const faceHeight = chin.y - eyebrowY;
            const faceWidth = rightCheek.x - leftCheek.x;
            
            // Moderate bounding box - enough for hair but not too much background
            const topPadding = faceHeight * 0.75;  // Room for hair
            const sidePadding = faceWidth * 0.2;   // Moderate sides
            const bottomPadding = faceHeight * 0.45;  // Generous chin padding
            
            let minX = leftCheek.x - sidePadding;
            let maxX = rightCheek.x + sidePadding;
            let minY = eyebrowY - topPadding;
            let maxY = chin.y + bottomPadding;
            
            // Clamp to image bounds
            minX = Math.max(0, minX);
            minY = Math.max(0, minY);
            maxX = Math.min(imgWidth, maxX);
            maxY = Math.min(imgHeight, maxY);
            
            const cropWidth = maxX - minX;
            const cropHeight = maxY - minY;
            
            // Output size
            const outputWidth = 220;
            const outputHeight = 280;
            
            faceCanvas.width = outputWidth;
            faceCanvas.height = outputHeight;
            
            // Calculate scale to fit
            const scale = Math.min(outputWidth / cropWidth, outputHeight / cropHeight) * 0.95;
            const scaledWidth = cropWidth * scale;
            const scaledHeight = cropHeight * scale;
            const offsetX = (outputWidth - scaledWidth) / 2;
            const offsetY = (outputHeight - scaledHeight) / 2;
            
            ctx.clearRect(0, 0, outputWidth, outputHeight);
            ctx.save();
            
            // Transform function for points
            const tx = (pt) => ({
                x: (pt.x - minX) * scale + offsetX,
                y: (pt.y - minY) * scale + offsetY
            });
            
            // Get transformed key points
            const tForeheadTop = tx(foreheadTop);
            const tLeftTemple = tx(leftTemple);
            const tRightTemple = tx(rightTemple);
            const tLeftCheek = tx(leftCheek);
            const tRightCheek = tx(rightCheek);
            const tLeftJaw = tx(leftJaw);
            const tRightJaw = tx(rightJaw);
            const tChin = tx(chin);
            
            // Calculate top of head (above forehead)
            const headTop = {
                x: tForeheadTop.x,
                y: tForeheadTop.y - (topPadding * scale * 0.6)
            };
            
            // Draw head-shaped outline
            ctx.beginPath();
            
            // Start at top of head
            ctx.moveTo(headTop.x, headTop.y);
            
            // Top of head to right temple (curved for skull shape)
            ctx.bezierCurveTo(
                headTop.x + scaledWidth * 0.3, headTop.y,
                tRightTemple.x + 8, headTop.y + 20,
                tRightTemple.x + 8, tRightTemple.y
            );
            
            // Right temple down to right cheek
            ctx.bezierCurveTo(
                tRightTemple.x + 8, tRightTemple.y + 20,
                tRightCheek.x + 6, tRightCheek.y - 20,
                tRightCheek.x + 6, tRightCheek.y
            );
            
            // Right cheek to right jaw
            ctx.bezierCurveTo(
                tRightCheek.x + 6, tRightCheek.y + 15,
                tRightJaw.x + 4, tRightJaw.y - 10,
                tRightJaw.x + 2, tRightJaw.y
            );
            
            // Right jaw to chin (smooth curve)
            ctx.bezierCurveTo(
                tRightJaw.x, tRightJaw.y + 20,
                tChin.x + 25, tChin.y + 15,
                tChin.x, tChin.y + 20
            );
            
            // Chin to left jaw
            ctx.bezierCurveTo(
                tChin.x - 25, tChin.y + 15,
                tLeftJaw.x, tLeftJaw.y + 20,
                tLeftJaw.x - 2, tLeftJaw.y
            );
            
            // Left jaw to left cheek
            ctx.bezierCurveTo(
                tLeftJaw.x - 4, tLeftJaw.y - 10,
                tLeftCheek.x - 6, tLeftCheek.y + 15,
                tLeftCheek.x - 6, tLeftCheek.y
            );
            
            // Left cheek up to left temple
            ctx.bezierCurveTo(
                tLeftCheek.x - 6, tLeftCheek.y - 20,
                tLeftTemple.x - 8, tLeftTemple.y + 20,
                tLeftTemple.x - 8, tLeftTemple.y
            );
            
            // Left temple back to top of head
            ctx.bezierCurveTo(
                tLeftTemple.x - 8, headTop.y + 20,
                headTop.x - scaledWidth * 0.3, headTop.y,
                headTop.x, headTop.y
            );
            
            ctx.closePath();
            ctx.clip();
            
            // Draw the face
            ctx.drawImage(
                img,
                minX, minY, cropWidth, cropHeight,
                offsetX, offsetY, scaledWidth, scaledHeight
            );
            
            // Remove light/white background pixels
            const imageData = ctx.getImageData(0, 0, outputWidth, outputHeight);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Check if pixel is very light (white or near-white background)
                const brightness = (r + g + b) / 3;
                const isGrayish = Math.abs(r - g) < 30 && Math.abs(g - b) < 30 && Math.abs(r - b) < 30;
                
                if (brightness > 230 && isGrayish) {
                    // Fully transparent for very white pixels
                    data[i + 3] = 0;
                } else if (brightness > 200 && isGrayish) {
                    // Fade out light gray pixels
                    data[i + 3] = Math.floor((230 - brightness) * 8.5);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            ctx.restore();
            
            // Now add blending effects
            ctx.save();
            
            // Create a feathered edge by drawing the outline with a gradient
            // This softens the hard edge of the cutout
            ctx.globalCompositeOperation = 'destination-out';
            
            // Create soft edge gradient
            const edgeSize = 10;
            ctx.lineWidth = edgeSize * 2;
            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.filter = 'blur(6px)';
            
            // Redraw the path for the soft edge
            ctx.beginPath();
            ctx.moveTo(headTop.x, headTop.y);
            ctx.bezierCurveTo(
                headTop.x + scaledWidth * 0.3, headTop.y,
                tRightTemple.x + 8, headTop.y + 20,
                tRightTemple.x + 8, tRightTemple.y
            );
            ctx.bezierCurveTo(
                tRightTemple.x + 8, tRightTemple.y + 20,
                tRightCheek.x + 6, tRightCheek.y - 20,
                tRightCheek.x + 6, tRightCheek.y
            );
            ctx.bezierCurveTo(
                tRightCheek.x + 6, tRightCheek.y + 15,
                tRightJaw.x + 4, tRightJaw.y - 10,
                tRightJaw.x + 2, tRightJaw.y
            );
            ctx.bezierCurveTo(
                tRightJaw.x, tRightJaw.y + 20,
                tChin.x + 25, tChin.y + 15,
                tChin.x, tChin.y + 20
            );
            ctx.bezierCurveTo(
                tChin.x - 25, tChin.y + 15,
                tLeftJaw.x, tLeftJaw.y + 20,
                tLeftJaw.x - 2, tLeftJaw.y
            );
            ctx.bezierCurveTo(
                tLeftJaw.x - 4, tLeftJaw.y - 10,
                tLeftCheek.x - 6, tLeftCheek.y + 15,
                tLeftCheek.x - 6, tLeftCheek.y
            );
            ctx.bezierCurveTo(
                tLeftCheek.x - 6, tLeftCheek.y - 20,
                tLeftTemple.x - 8, tLeftTemple.y + 20,
                tLeftTemple.x - 8, tLeftTemple.y
            );
            ctx.bezierCurveTo(
                tLeftTemple.x - 8, headTop.y + 20,
                headTop.x - scaledWidth * 0.3, headTop.y,
                headTop.x, headTop.y
            );
            ctx.closePath();
            ctx.stroke();
            
            ctx.restore();
            
            return faceCanvas.toDataURL('image/png');
        }

        function extractCenter() {
            const img = sourceImage;
            const imgWidth = img.naturalWidth;
            const imgHeight = img.naturalHeight;
            
            const size = Math.min(imgWidth, imgHeight);
            const cropX = (imgWidth - size) / 2;
            const cropY = (imgHeight - size) / 2;
            
            const outputSize = 220;
            faceCanvas.width = outputSize;
            faceCanvas.height = outputSize;
            
            ctx.clearRect(0, 0, outputSize, outputSize);
            ctx.save();
            
            ctx.beginPath();
            ctx.ellipse(outputSize / 2, outputSize / 2, outputSize / 2 - 5, outputSize / 2 - 5, 0, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            
            ctx.drawImage(
                img,
                cropX, cropY, size, size,
                0, 0, outputSize, outputSize
            );
            
            ctx.restore();
            
            return faceCanvas.toDataURL('image/png');
        }

        analyzeBtn.addEventListener('click', startAnalysis);

        function startAnalysis() {
            uploadScreen.style.display = 'none';
            analysisScreen.classList.add('show');
            
            let progress = 0;
            let messageIndex = 0;
            
            const interval = setInterval(() => {
                progress += Math.random() * 10 + 3;
                if (progress > 100) progress = 100;
                
                progressFill.style.width = progress + '%';
                
                if (messageIndex < analysisMessages.length && progress > (messageIndex + 1) * 8) {
                    analysisText.textContent = analysisMessages[messageIndex];
                    messageIndex++;
                }
                
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(showResults, 500);
                }
            }, 280);
        }

        function generateSausageSVG(color, highlight) {
            // Generate random sizzle positions
            const sizzles = [];
            for (let i = 0; i < 5; i++) {
                sizzles.push({
                    x: 40 + Math.random() * 120,
                    y: 220 + Math.random() * 20,
                    size: 2 + Math.random() * 3,
                    delay: Math.random() * 2
                });
            }
            
            return `
                <svg viewBox="0 0 200 280" class="sausage-svg">
                    <!-- Definitions for gradients and filters -->
                    <defs>
                        <radialGradient id="panShine" cx="30%" cy="30%" r="60%">
                            <stop offset="0%" style="stop-color:#555"/>
                            <stop offset="100%" style="stop-color:#222"/>
                        </radialGradient>
                        <radialGradient id="sausageGrad" cx="35%" cy="30%" r="65%">
                            <stop offset="0%" style="stop-color:${highlight}"/>
                            <stop offset="100%" style="stop-color:${color}"/>
                        </radialGradient>
                        <filter id="sizzleGlow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="2" result="blur"/>
                            <feComposite in="SourceGraphic" in2="blur" operator="over"/>
                        </filter>
                    </defs>
                    
                    <!-- Frying pan with gradient -->
                    <ellipse cx="100" cy="250" rx="90" ry="28" fill="#333"/>
                    <ellipse cx="100" cy="245" rx="85" ry="24" fill="url(#panShine)"/>
                    <ellipse cx="100" cy="241" rx="80" ry="20" fill="#1a1a1a"/>
                    
                    <!-- Oil sheen -->
                    <ellipse cx="100" cy="238" rx="70" ry="16" fill="#2a2a2a" opacity="0.8"/>
                    <ellipse cx="85" cy="235" rx="25" ry="8" fill="#3a3a3a" opacity="0.5"/>
                    
                    <!-- Sizzle bubbles -->
                    ${sizzles.map(s => `
                        <circle cx="${s.x}" cy="${s.y}" r="${s.size}" fill="#ffcc00" filter="url(#sizzleGlow)" opacity="0.8">
                            <animate attributeName="r" values="${s.size};${s.size + 2};0" dur="0.8s" begin="${s.delay}s" repeatCount="indefinite"/>
                            <animate attributeName="opacity" values="0.8;0.6;0" dur="0.8s" begin="${s.delay}s" repeatCount="indefinite"/>
                            <animate attributeName="cy" values="${s.y};${s.y - 10}" dur="0.8s" begin="${s.delay}s" repeatCount="indefinite"/>
                        </circle>
                    `).join('')}
                    
                    <!-- Sausage shadow -->
                    <ellipse cx="108" cy="232" rx="45" ry="12" fill="rgba(0,0,0,0.4)"/>
                    
                    <!-- Sausage body with gradient -->
                    <ellipse cx="100" cy="145" rx="44" ry="98" fill="url(#sausageGrad)"/>
                    
                    <!-- Sausage shine -->
                    <ellipse cx="78" cy="130" rx="12" ry="50" fill="white" opacity="0.15"/>
                    <ellipse cx="75" cy="120" rx="6" ry="30" fill="white" opacity="0.1"/>
                    
                    <!-- Sausage bottom end -->
                    <ellipse cx="100" cy="238" rx="38" ry="15" fill="${color}"/>
                    <ellipse cx="95" cy="236" rx="20" ry="8" fill="${highlight}" opacity="0.3"/>
                    
                    <!-- Grill marks with better styling -->
                    <path d="M60 175 Q100 162 140 175" stroke="#3d2010" stroke-width="5" fill="none" opacity="0.5" stroke-linecap="round"/>
                    <path d="M65 205 Q100 192 135 205" stroke="#3d2010" stroke-width="5" fill="none" opacity="0.5" stroke-linecap="round"/>
                    
                    <!-- Extra char marks -->
                    <ellipse cx="120" cy="190" rx="8" ry="4" fill="#3d2010" opacity="0.3" transform="rotate(-20 120 190)"/>
                    <ellipse cx="75" cy="170" rx="6" ry="3" fill="#3d2010" opacity="0.25" transform="rotate(15 75 170)"/>
                    
                    <!-- Steam with better animation -->
                    <g opacity="0.7">
                        <path d="M50 35 Q45 20 55 8" stroke="#fff" stroke-width="3" fill="none" stroke-linecap="round">
                            <animate attributeName="d" values="M50 35 Q45 20 55 8;M50 35 Q55 20 45 8;M50 35 Q45 20 55 8" dur="2s" repeatCount="indefinite"/>
                            <animate attributeName="opacity" values="0.7;0.3;0.7" dur="2s" repeatCount="indefinite"/>
                        </path>
                        <path d="M100 30 Q95 12 105 -5" stroke="#fff" stroke-width="4" fill="none" stroke-linecap="round">
                            <animate attributeName="d" values="M100 30 Q95 12 105 -5;M100 30 Q105 12 95 -5;M100 30 Q95 12 105 -5" dur="2.5s" repeatCount="indefinite"/>
                            <animate attributeName="opacity" values="0.7;0.4;0.7" dur="2.5s" repeatCount="indefinite"/>
                        </path>
                        <path d="M150 35 Q145 20 155 8" stroke="#fff" stroke-width="3" fill="none" stroke-linecap="round">
                            <animate attributeName="d" values="M150 35 Q145 20 155 8;M150 35 Q155 20 145 8;M150 35 Q145 20 155 8" dur="1.8s" repeatCount="indefinite"/>
                            <animate attributeName="opacity" values="0.7;0.3;0.7" dur="1.8s" repeatCount="indefinite"/>
                        </path>
                    </g>
                    
                    <!-- Little arms (cute!) -->
                    <g fill="${color}" stroke="${highlight}" stroke-width="1">
                        <!-- Left arm waving -->
                        <ellipse cx="52" cy="150" rx="12" ry="6" transform="rotate(-30 52 150)">
                            <animate attributeName="transform" values="rotate(-30 52 150);rotate(-45 52 150);rotate(-30 52 150)" dur="0.5s" repeatCount="indefinite"/>
                        </ellipse>
                        <!-- Right arm -->
                        <ellipse cx="148" cy="155" rx="12" ry="6" transform="rotate(20 148 155)"/>
                    </g>
                    
                    <!-- Little feet at bottom -->
                    <ellipse cx="80" cy="250" rx="10" ry="6" fill="${color}"/>
                    <ellipse cx="120" cy="250" rx="10" ry="6" fill="${color}"/>
                </svg>
            `;
        }

        function createSausageCard(faceDataUrl, index) {
            const sausage = sausageTypes[Math.floor(Math.random() * sausageTypes.length)];
            const quote = sausage.quotes[Math.floor(Math.random() * sausage.quotes.length)];
            
            // Pick 3 random unique names
            const shuffledNames = [...sausage.names].sort(() => Math.random() - 0.5);
            const selectedNames = shuffledNames.slice(0, 3);
            
            const stats = {
                sizzle: Math.floor(Math.random() * 40 + 60),
                meat: Math.floor(Math.random() * 40 + 60),
                banger: Math.floor(Math.random() * 40 + 60)
            };

            const card = document.createElement('div');
            card.className = 'sausage-card';
            card.innerHTML = `
                <div class="sausage-quote">${quote}</div>
                <div class="sausage-result">
                    <div class="sausage-body">
                        ${generateSausageSVG(sausage.color, sausage.highlight)}
                    </div>
                    <img class="face-overlay" src="${faceDataUrl}" alt="Sausage ${index + 1}">
                </div>
                <div class="sausage-type">${sausage.name}</div>
                <div class="sausage-description">${sausage.description}</div>
                <div class="sausage-names">
                    <span class="sausage-names-label">üè∑Ô∏è Suggested names:</span>
                    <span class="sausage-names-list">${selectedNames.join(', ')}</span>
                </div>
                <div class="stats">
                    <div class="stat-row">
                        <span class="stat-label">üî• Sizzle</span>
                        <div class="stat-bar"><div class="stat-fill sizzle" style="width: 0%"></div></div>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">ü•© Meaty</span>
                        <div class="stat-bar"><div class="stat-fill meat" style="width: 0%"></div></div>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üí• Banger</span>
                        <div class="stat-bar"><div class="stat-fill banger" style="width: 0%"></div></div>
                    </div>
                </div>
            `;

            setTimeout(() => {
                const statBars = card.querySelectorAll('.stat-fill');
                statBars[0].style.width = stats.sizzle + '%';
                statBars[1].style.width = stats.meat + '%';
                statBars[2].style.width = stats.banger + '%';
            }, 300 + index * 200);

            return card;
        }

        function showResults() {
            analysisScreen.classList.remove('show');
            analysisScreen.style.display = 'none';
            resultsScreen.classList.add('show');
            
            sausagesGrid.innerHTML = '';
            
            console.log('Showing results. Faces:', detectedFaceLandmarks.length);
            
            if (detectedFaceLandmarks.length > 0) {
                detectedFaceLandmarks.forEach((landmarks, index) => {
                    const faceDataUrl = extractFaceWithPreciseMask(landmarks);
                    const card = createSausageCard(faceDataUrl, index);
                    sausagesGrid.appendChild(card);
                });
            } else {
                const faceDataUrl = extractCenter();
                const card = createSausageCard(faceDataUrl, 0);
                sausagesGrid.appendChild(card);
            }
        }

        tryAgainBtn.addEventListener('click', () => {
            resultsScreen.classList.remove('show');
            resultsScreen.style.display = 'none';
            uploadScreen.style.display = 'block';
            previewContainer.classList.remove('show');
            analyzeBtn.classList.remove('show');
            facesFound.style.display = 'none';
            progressFill.style.width = '0%';
            detectedFaceLandmarks = [];
            imageDataUrl = null;
            fileInput.value = '';
        });

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('Service Worker registered!', reg))
                .catch(err => console.log('Service Worker registration failed:', err));
        }
    </script>
</body>
</html>
